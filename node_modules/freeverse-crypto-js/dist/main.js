var $cMhOD$web3ethaccounts = require("web3-eth-accounts");
var $cMhOD$cryptojs = require("crypto-js");
var $cMhOD$ethcrypto = require("eth-crypto");

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

var $466f9c9783c1944f$require$Accounts = ($parcel$interopDefault($cMhOD$web3ethaccounts));

var $466f9c9783c1944f$require$CryptoJS = ($parcel$interopDefault($cMhOD$cryptojs));

// Use a an AES-Standard KDF (Key Derivation Function) to generate (IV, key) from (password, salt)
// This is a standard step that makes brute-force attacks much harder
const $466f9c9783c1944f$var$applyKDF = (password, salt)=>{
    const keyBytes = $466f9c9783c1944f$require$CryptoJS.PBKDF2(password, salt, {
        keySize: 12,
        iterations: 1000
    });
    // take first 32 bytes as key
    const key = $466f9c9783c1944f$require$CryptoJS.lib.WordArray.create(keyBytes.words, 32);
    // skip first 32 bytes and take next 16 bytes as IV
    const iv = $466f9c9783c1944f$require$CryptoJS.lib.WordArray.create(keyBytes.words.splice(8), 16);
    return {
        key: key,
        iv: iv
    };
};
// Returns a Web3 Account with a brand new pair (privateKey/user_id)
// capable of signing on behalf of privateKey
const $466f9c9783c1944f$var$createNewAccount = ()=>new $466f9c9783c1944f$require$Accounts().create()
;
// Returns a Web3 Account from a given privateKey,
// capable of signing on behalf of privateKey
const $466f9c9783c1944f$var$accountFromPrivateKey = (privKey)=>{
    try {
        return new $466f9c9783c1944f$require$Accounts().privateKeyToAccount(privKey);
    } catch  {
        throw new Error('Private Key does not have correct format');
    }
};
/**
 * Returns the public freeverseID corresponding to the provided private key.
 * The freeverseID can be shared. The Private key should never leave the user's control.
 * @deprecated since version 1.0.7
 */ const $466f9c9783c1944f$var$freeverseIdFromPrivateKey = (privKey)=>{
    const account = $466f9c9783c1944f$var$accountFromPrivateKey(privKey);
    return account.address;
};
/**
 * Returns the public freeverseID corresponding to the provided private key.
 * The freeverseID can be shared. The Private key should never leave the user's control.
 */ const $466f9c9783c1944f$var$web3AddressFromPrivateKey = (privKey)=>{
    const account = $466f9c9783c1944f$var$accountFromPrivateKey(privKey);
    return account.address;
};
// Generates an Encrypted Identity, which is the concat of:
// - salt (32b)
// - the encryption of hte provided private key using the provided user password
// The encryption the AES standard with an AES recommended KDF.
// The user should store the Encrypted Identity in a safe place,
// an attacker would need access to it as well as knowledge of the user-entered password.
const $466f9c9783c1944f$var$encryptIdentity = (pvk, password)=>{
    const salt = $466f9c9783c1944f$require$CryptoJS.lib.WordArray.random(16);
    // generate (IV, key) from an AES-secure Key Derivation Function
    const kdf = $466f9c9783c1944f$var$applyKDF(password, salt);
    const pvkNoTrail = pvk.slice(0, 2) === '0x' ? pvk.slice(2) : pvk;
    const pvkWords = $466f9c9783c1944f$require$CryptoJS.enc.Hex.parse(pvkNoTrail);
    const encrypted = $466f9c9783c1944f$require$CryptoJS.AES.encrypt(pvkWords, kdf.key, {
        iv: kdf.iv
    });
    return salt.concat(encrypted.ciphertext).toString($466f9c9783c1944f$require$CryptoJS.enc.Hex);
};
// Decryption of an encrypted private key, given a user-entered password, following AES standard.
const $466f9c9783c1944f$var$decryptIdentity = (encryptedIdentity, password)=>{
    // An encrypted Identity is a hex-formatted string, which is the concat of:
    // ...salt (32bit)
    const salt = $466f9c9783c1944f$require$CryptoJS.enc.Hex.parse(encryptedIdentity.slice(0, 32));
    // ..and encrypted private key
    const cipherText = $466f9c9783c1944f$require$CryptoJS.enc.Hex.parse(encryptedIdentity.slice(32));
    // generate (IV, key) from an AES-secure Key Derivation Function, and decrypt
    const kdf = $466f9c9783c1944f$var$applyKDF(password, salt);
    const plaintextArray = $466f9c9783c1944f$require$CryptoJS.AES.decrypt({
        ciphertext: cipherText,
        salt: ''
    }, kdf.key, {
        iv: kdf.iv
    });
    const privKey = `0x${plaintextArray.toString($466f9c9783c1944f$require$CryptoJS.enc.Hex)}`;
    // Before returning, check that a valid account can be generated from this privKey
    // Otherwise: throw.
    try {
        $466f9c9783c1944f$var$web3AddressFromPrivateKey(privKey);
    } catch  {
        throw new Error('The Encrypted ID and Password entered do not match');
    }
    return privKey;
};
// encrypts a string so that it can only be decrypted
// by the owner of the privKey that corresponds to the publicKey
const $466f9c9783c1944f$var$encryptWithPublicKey = async (textToEncrypt, publicKey)=>{
    // obtaining an object with the encrypted data
    const encryptedObject = await $cMhOD$ethcrypto.encryptWithPublicKey(publicKey, textToEncrypt);
    // converting the encrypted object into a encrypted String
    const encryptedString = $cMhOD$ethcrypto.cipher.stringify(encryptedObject);
    return encryptedString;
};
// decrypts a string that was encrypted for a given publicKey
const $466f9c9783c1944f$var$decryptWithPrivateKey = async (encryptedString, privateKey)=>{
    // converting the encypted String into an encrypted object
    const encryptedObject = $cMhOD$ethcrypto.cipher.parse(encryptedString);
    // decrypt the en encrypted object with the private key
    const decrypted = await $cMhOD$ethcrypto.decryptWithPrivateKey(privateKey, encryptedObject);
    return decrypted;
};
const $466f9c9783c1944f$var$publicKeyFromPrivateKey = (privKey)=>$cMhOD$ethcrypto.publicKeyByPrivateKey(privKey)
;
module.exports = {
    freeverseIdFromPrivateKey: $466f9c9783c1944f$var$freeverseIdFromPrivateKey,
    web3AddressFromPrivateKey: $466f9c9783c1944f$var$web3AddressFromPrivateKey,
    encryptIdentity: $466f9c9783c1944f$var$encryptIdentity,
    decryptIdentity: $466f9c9783c1944f$var$decryptIdentity,
    createNewAccount: $466f9c9783c1944f$var$createNewAccount,
    accountFromPrivateKey: $466f9c9783c1944f$var$accountFromPrivateKey,
    encryptWithPublicKey: $466f9c9783c1944f$var$encryptWithPublicKey,
    decryptWithPrivateKey: $466f9c9783c1944f$var$decryptWithPrivateKey,
    publicKeyFromPrivateKey: $466f9c9783c1944f$var$publicKeyFromPrivateKey
};


//# sourceMappingURL=main.js.map
