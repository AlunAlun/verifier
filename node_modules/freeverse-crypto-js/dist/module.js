import $c6Hue$web3ethaccounts from "web3-eth-accounts";
import $c6Hue$cryptojs from "crypto-js";
import {encryptWithPublicKey as $c6Hue$encryptWithPublicKey, cipher as $c6Hue$cipher, decryptWithPrivateKey as $c6Hue$decryptWithPrivateKey, publicKeyByPrivateKey as $c6Hue$publicKeyByPrivateKey} from "eth-crypto";

var $c4ed1fe2787c9fda$exports = {};

var $c4ed1fe2787c9fda$require$Accounts = $c6Hue$web3ethaccounts;

var $c4ed1fe2787c9fda$require$CryptoJS = $c6Hue$cryptojs;

// Use a an AES-Standard KDF (Key Derivation Function) to generate (IV, key) from (password, salt)
// This is a standard step that makes brute-force attacks much harder
const $c4ed1fe2787c9fda$var$applyKDF = (password, salt)=>{
    const keyBytes = $c4ed1fe2787c9fda$require$CryptoJS.PBKDF2(password, salt, {
        keySize: 12,
        iterations: 1000
    });
    // take first 32 bytes as key
    const key = $c4ed1fe2787c9fda$require$CryptoJS.lib.WordArray.create(keyBytes.words, 32);
    // skip first 32 bytes and take next 16 bytes as IV
    const iv = $c4ed1fe2787c9fda$require$CryptoJS.lib.WordArray.create(keyBytes.words.splice(8), 16);
    return {
        key: key,
        iv: iv
    };
};
// Returns a Web3 Account with a brand new pair (privateKey/user_id)
// capable of signing on behalf of privateKey
const $c4ed1fe2787c9fda$var$createNewAccount = ()=>new $c4ed1fe2787c9fda$require$Accounts().create()
;
// Returns a Web3 Account from a given privateKey,
// capable of signing on behalf of privateKey
const $c4ed1fe2787c9fda$var$accountFromPrivateKey = (privKey)=>{
    try {
        return new $c4ed1fe2787c9fda$require$Accounts().privateKeyToAccount(privKey);
    } catch  {
        throw new Error('Private Key does not have correct format');
    }
};
/**
 * Returns the public freeverseID corresponding to the provided private key.
 * The freeverseID can be shared. The Private key should never leave the user's control.
 * @deprecated since version 1.0.7
 */ const $c4ed1fe2787c9fda$var$freeverseIdFromPrivateKey = (privKey)=>{
    const account = $c4ed1fe2787c9fda$var$accountFromPrivateKey(privKey);
    return account.address;
};
/**
 * Returns the public freeverseID corresponding to the provided private key.
 * The freeverseID can be shared. The Private key should never leave the user's control.
 */ const $c4ed1fe2787c9fda$var$web3AddressFromPrivateKey = (privKey)=>{
    const account = $c4ed1fe2787c9fda$var$accountFromPrivateKey(privKey);
    return account.address;
};
// Generates an Encrypted Identity, which is the concat of:
// - salt (32b)
// - the encryption of hte provided private key using the provided user password
// The encryption the AES standard with an AES recommended KDF.
// The user should store the Encrypted Identity in a safe place,
// an attacker would need access to it as well as knowledge of the user-entered password.
const $c4ed1fe2787c9fda$var$encryptIdentity = (pvk, password)=>{
    const salt = $c4ed1fe2787c9fda$require$CryptoJS.lib.WordArray.random(16);
    // generate (IV, key) from an AES-secure Key Derivation Function
    const kdf = $c4ed1fe2787c9fda$var$applyKDF(password, salt);
    const pvkNoTrail = pvk.slice(0, 2) === '0x' ? pvk.slice(2) : pvk;
    const pvkWords = $c4ed1fe2787c9fda$require$CryptoJS.enc.Hex.parse(pvkNoTrail);
    const encrypted = $c4ed1fe2787c9fda$require$CryptoJS.AES.encrypt(pvkWords, kdf.key, {
        iv: kdf.iv
    });
    return salt.concat(encrypted.ciphertext).toString($c4ed1fe2787c9fda$require$CryptoJS.enc.Hex);
};
// Decryption of an encrypted private key, given a user-entered password, following AES standard.
const $c4ed1fe2787c9fda$var$decryptIdentity = (encryptedIdentity, password)=>{
    // An encrypted Identity is a hex-formatted string, which is the concat of:
    // ...salt (32bit)
    const salt = $c4ed1fe2787c9fda$require$CryptoJS.enc.Hex.parse(encryptedIdentity.slice(0, 32));
    // ..and encrypted private key
    const cipherText = $c4ed1fe2787c9fda$require$CryptoJS.enc.Hex.parse(encryptedIdentity.slice(32));
    // generate (IV, key) from an AES-secure Key Derivation Function, and decrypt
    const kdf = $c4ed1fe2787c9fda$var$applyKDF(password, salt);
    const plaintextArray = $c4ed1fe2787c9fda$require$CryptoJS.AES.decrypt({
        ciphertext: cipherText,
        salt: ''
    }, kdf.key, {
        iv: kdf.iv
    });
    const privKey = `0x${plaintextArray.toString($c4ed1fe2787c9fda$require$CryptoJS.enc.Hex)}`;
    // Before returning, check that a valid account can be generated from this privKey
    // Otherwise: throw.
    try {
        $c4ed1fe2787c9fda$var$web3AddressFromPrivateKey(privKey);
    } catch  {
        throw new Error('The Encrypted ID and Password entered do not match');
    }
    return privKey;
};
// encrypts a string so that it can only be decrypted
// by the owner of the privKey that corresponds to the publicKey
const $c4ed1fe2787c9fda$var$encryptWithPublicKey = async (textToEncrypt, publicKey)=>{
    // obtaining an object with the encrypted data
    const encryptedObject = await $c6Hue$encryptWithPublicKey(publicKey, textToEncrypt);
    // converting the encrypted object into a encrypted String
    const encryptedString = $c6Hue$cipher.stringify(encryptedObject);
    return encryptedString;
};
// decrypts a string that was encrypted for a given publicKey
const $c4ed1fe2787c9fda$var$decryptWithPrivateKey = async (encryptedString, privateKey)=>{
    // converting the encypted String into an encrypted object
    const encryptedObject = $c6Hue$cipher.parse(encryptedString);
    // decrypt the en encrypted object with the private key
    const decrypted = await $c6Hue$decryptWithPrivateKey(privateKey, encryptedObject);
    return decrypted;
};
const $c4ed1fe2787c9fda$var$publicKeyFromPrivateKey = (privKey)=>$c6Hue$publicKeyByPrivateKey(privKey)
;
$c4ed1fe2787c9fda$exports = {
    freeverseIdFromPrivateKey: $c4ed1fe2787c9fda$var$freeverseIdFromPrivateKey,
    web3AddressFromPrivateKey: $c4ed1fe2787c9fda$var$web3AddressFromPrivateKey,
    encryptIdentity: $c4ed1fe2787c9fda$var$encryptIdentity,
    decryptIdentity: $c4ed1fe2787c9fda$var$decryptIdentity,
    createNewAccount: $c4ed1fe2787c9fda$var$createNewAccount,
    accountFromPrivateKey: $c4ed1fe2787c9fda$var$accountFromPrivateKey,
    encryptWithPublicKey: $c4ed1fe2787c9fda$var$encryptWithPublicKey,
    decryptWithPrivateKey: $c4ed1fe2787c9fda$var$decryptWithPrivateKey,
    publicKeyFromPrivateKey: $c4ed1fe2787c9fda$var$publicKeyFromPrivateKey
};


export {$c4ed1fe2787c9fda$exports as default};
//# sourceMappingURL=module.js.map
